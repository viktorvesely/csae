import numpy as np
import chess
import mind_control
from pathlib import Path
import torch
import activations
from collections import Counter
import lc0_concepts
import os.path
import chess.svg
from collections import Counter
from collections import defaultdict
import sys

def contains_king_move(moves, board):
  move = chess.Move.from_uci(move_uci)
  
  if not board.is_legal(move):
    return False 

  piece = board.piece_at(move.from_square)
  return piece is not None and piece.piece_type == chess.KING


def get_game_indexes_with_king_move(chess_games):
  games_with_king_move = []
  for idx, game in enumerate(chess_games):
    fen = game[0]
    moves = game[1:]
    board = chess.Board(fen)
    for move_uci in moves:
      if not move_uci.strip():
        continue

      move = chess.Move.from_uci(move_uci)
      if not board.is_legal(move):
        continue
      
      piece = board.piece_at(move.from_square)
      if piece is not None and piece.piece_type == chess.KING:
        games_with_king_move.append(idx)
        break
        
  return games_with_king_move

def get_pawn_flanks_count_dict(traj):
  all_concepts = []
  for idx, game in enumerate(traj):
    fen = game[0]
    moves = game[1:]
    board = chess.Board(fen)
    all_concepts.extend(get_flank_pawn_concepts(moves, board, idx))
  return all_concepts

def get_flank_pawn_concepts(moves_uci, board, game_idx):
  concepts = []
  for move_uci in moves_uci:
    if not move_uci.strip():
      continue

    move = chess.Move.from_uci(move_uci)
    if not board.is_legal(move):
      continue

    piece = board.piece_at(move.from_square)
    if piece and piece.piece_type == chess.PAWN:
      from_file = chess.square_file(move.from_square)
      from_rank = chess.square_rank(move.from_square)
      to_rank = chess.square_rank(move.to_square)
      rank_diff = abs(to_rank - from_rank)

      if from_file == 7:
        if piece.color == chess.WHITE:
          if rank_diff == 2:
            concepts.append(("white_double_H", game_idx))
            return concepts
        else:
          if rank_diff == 2:
            concepts.append(("black_double_H", game_idx))
            return concepts

    board.push(move)

  return concepts

def print_label_count(labels):
  unique_labels, counts = np.unique(labels, return_counts=True)
  
  label_count = dict(zip(unique_labels, counts))
  print(label_count)
      
  return label_count

def get_all_fens(input_folder):
  results = [] 
  for traj_file_idx in range(25, 28):
    chess_games = np.load(os.path.join(input_folder, f"trajectory_{traj_file_idx}.npy"), allow_pickle=True)
    results.append([str(fen) for fen in chess_games[:, 0]])
    
  fens = sum(results, [])
  return fens

def get_concepts(chess_games):
  records = []
  for idx, game in enumerate(chess_games):
    fen = game[0]
    moves = game[1:]
    scenarios =lc0_concepts.detect_scenarios(fen, moves)
    for scenario in scenarios:
      name, at_move, starting_fen, old_fen, new_fen, moves = scenario
      records.append(lc0_concepts.ScenarioRecord(name, at_move, starting_fen, old_fen, new_fen, idx, moves))
  return records

def get_svg_sequence(trajectory, board_size=150):
    boards_svg = []
    board = chess.Board(trajectory[0])
    boards_svg.append(chess.svg.board(board=board, size=board_size))
    for move_uci in trajectory[1:]:

        if move_uci == "":
            break
        move = chess.Move.from_uci(move_uci)
        board.push(move)
        boards_svg.append(chess.svg.board(board=board, size=board_size, lastmove=move))
    return boards_svg

# Generated by ChatGPT
def generate_chess_html(trajectory_pairs, file_path):
    """Generate an HTML document displaying pairs of chess trajectories side by side."""
    # HTML parts
    html_parts = [
        "<html>",
        "<head>",
        "<meta charset='utf-8'>",
        "<title>Altered Chess Trajectories</title>",
        "<style>",
        "body { font-family: Arial, sans-serif; background-color: #f4f4f4; margin: 20px; }",
        ".scroll-container { display: flex; flex-wrap: wrap; justify-content: space-around; }",  # Allow wrapping for multiple boxes
        ".game-box { display: flex; flex-direction: row; border: 1px solid #ddd; border-radius: 8px; margin: 10px; padding: 10px; }",
        ".trajectory { display: flex; flex-direction: column; margin: 5px; }",
        ".trajectory svg { margin-bottom: 10px; }",
        "</style>",
        "</head>",
        "<body>",
        "<h2>Altered Chess Trajectories</h2>",
        "<div class='scroll-container'>"
    ]

    # For each pair of trajectories, create a "game-box"
    for trajectory_left, trajectory_right in trajectory_pairs:
        # Generate SVG sequences for both trajectories
        boards_svg_left = get_svg_sequence(trajectory_left)
        boards_svg_right = get_svg_sequence(trajectory_right)

        # Start the game box and two trajectory divs (one for each trajectory)
        html_parts.append("<div class='game-box'>")

        # Trajectory on the left
        html_parts.append("<div class='trajectory'>")
        for svg in boards_svg_left:
            html_parts.append(f"<div>{svg}</div>")
        html_parts.append("</div>")  

        # Trajectory on the right
        html_parts.append("<div class='trajectory'>")
        for svg in boards_svg_right:
            html_parts.append(f"<div>{svg}</div>")
        html_parts.append("</div>")

        html_parts.append("</div>")

    # Close the scroll container and the rest of the HTML
    html_parts.append("</div>")  
    html_parts.append("</body>")
    html_parts.append("</html>")

    # Join all the HTML parts into a single string
    html_content = "\n".join(html_parts)

    with open(file_path, "w") as f:
        f.write(html_content)

def get_opposing_trajectory_pairs_and_count(normal_concepts, altered_concepts, all_normal_traj):
  trajectory_pairs = []
  both_played_concept_count = 0
  only_altered_played_concept = 0
  only_normal_played_concept = 0
  for altered_concept in altered_concepts:
    name, at_move, starting_fen, old_fen, new_fen, idx, moves = altered_concept
	
    if (name == "knight_fork"):
      normal_concepts = np.array(normal_concepts, dtype=object)
      matches = (normal_concepts[:, 5] == idx) & (normal_concepts[:, 0] == name)
      if np.any(matches):
        both_played_concept_count += 1
        continue
        
      only_altered_played_concept += 1
      altered_traject = np.concatenate(([starting_fen], moves))
      trajectory_pairs.append((all_normal_traj[idx], altered_traject))
        
  return trajectory_pairs, both_played_concept_count

def get_count_both_playing_same_move(normal_concepts, altered_concepts):
  count_same_move = 0
  normal_games = group_by_game_idx(normal_concepts)
  altered_games = group_by_game_idx(altered_concepts)
  
  common_game_idxs = set(normal_games) & set(altered_games)
  for idx in sorted(common_game_idxs):
    concepts_a = normal_games[idx]
    concepts_b = altered_games[idx]
    if concepts_a == concepts_b:
      count_same_move += 1
  return count_same_move
      
def top_down_analysis(output_folder, normal_traj, altered_traj):
  print("analysing normal concepts")
  normal_concepts = get_concepts(normal_traj)
  
  normal_label_count_dict = print_label_count([sample[0] for sample in normal_concepts])
  
  print("analysing altered concepts")
  altered_concepts = get_concepts(altered_traj)
  
  print("altered")
  altered_label_count_dict = print_label_count([sample[0] for sample in altered_concepts])
  
  trajectory_pairs, both_played_concept_count = get_opposing_trajectory_pairs_and_count(normal_concepts, altered_concepts, normal_traj)
  
  only_altered_played_concept = altered_label_count_dict["knight_fork"] - both_played_concept_count
  only_normal_played_concept = normal_label_count_dict["knight_fork"] - both_played_concept_count
  
  both_not_played_concept_count = len(normal_traj) - both_played_concept_count - only_altered_played_concept - only_normal_played_concept
  print(f"both played: {both_played_concept_count}, altered played: {only_altered_played_concept}, normal played:{only_normal_played_concept}, both not played: {both_not_played_concept_count}") 
  generate_chess_html(trajectory_pairs[10:50], os.path.join(output_folder, "normal_vs_mind_control.html"))

def group_by_game_idx(concept_pairs):
    grouped = defaultdict(list)
    for concept, game_idx in concept_pairs:
        grouped[game_idx].append(concept)
    return grouped

def bottom_up_analysis_pawn_flank(normal_traj, altered_traj):
  print("normal: ")
  normal_pawn_flanks_concept_game_pairs = get_pawn_flanks_count_dict(normal_traj)
  print_label_count([sample[0] for sample in normal_pawn_flanks_concept_game_pairs])

  
  print("altered: ")
  altered_pawn_flanks_concept_game_pairs = get_pawn_flanks_count_dict(altered_traj)
  print_label_count([sample[0] for sample in altered_pawn_flanks_concept_game_pairs])
  count_same_move = get_count_both_playing_same_move(normal_pawn_flanks_concept_game_pairs, altered_pawn_flanks_concept_game_pairs)
  print(count_same_move)

def bottom_up_analysis_king_move(normal_traj, altered_traj, output_folder):
  normal_king_indexes = get_game_indexes_with_king_move(normal_traj)
  altered_king_indexes = get_game_indexes_with_king_move(altered_traj)
  print(f"normal king count:  {len(normal_king_indexes)}")
  print(f"altered king count:  {len(altered_king_indexes)}")
  count_both_king_move = len(set(normal_king_indexes) & set(altered_king_indexes))
  print(f"count both: {count_both_king_move}")
  traj_pairs = []
  for idx in altered_king_indexes:
    traj_pairs.append((normal_traj[idx], altered_traj[idx]))

  generate_chess_html(traj_pairs[:50], os.path.join(output_folder, "king_move.html"))

def create_trajectories(input_folder, output_folder, name_normal_traj, name_altered_traj, indices):
    path_normal_traj = os.path.join(output_folder, "trajectory_" + name_normal_traj + ".npy")
    path_altered_traj = os.path.join(output_folder, "trajectory_" + name_altered_traj + ".npy")
    if not os.path.isfile(path_normal_traj) or not os.path.isfile(path_altered_traj):
        fens = get_all_fens(input_folder)

    lc0 = None
    if not os.path.isfile(path_normal_traj):
        lc0 = activations.load_lc0()
        with torch.no_grad():
            activations.process_trajectories(lc0, fens, name_normal_traj, Path(output_folder), depth=6)

    if not os.path.isfile(path_altered_traj):
        if lc0 is None:
            lc0 = mind_control.load_lc0()

        sae = mind_control.load_sae()

        lm_indices, lm_factors = mind_control.get_latent_manipulator(*indices, factor=2)  # king move 63744, 7722, 34463, 63751,106345, 79750, 83977, 11679, factor=2) #pawn flank 59983, 7734, 18678, 106357, #knight fork: 18677, 32541, 63744

        with torch.no_grad():
            mind_control.altered_trajectories(Path(output_folder), sae, lc0, fens, name_altered_traj, lm_indices, lm_factors, depth=6)

    return path_normal_traj, path_altered_traj

def analysis(output_folder, analysis_type, path_normal_traj, path_altered_traj):
    normal_traj = np.load(path_normal_traj)
    altered_traj = np.load(path_altered_traj)

    if analysis_type == "knight_fork":
        top_down_analysis(output_folder, normal_traj, altered_traj)
    elif analysis_type == "king_move":
        traj_pairs = bottom_up_analysis_king_move(normal_traj, altered_traj, output_folder)
    elif analysis_type == "pawn_flank":
        bottom_up_analysis_pawn_flank(normal_traj, altered_traj)

#

def main(arguments):
  game_input_folder = arguments[0]
  output_folder = arguments[1]
  name_normal_traj = arguments[2]
  name_altered_traj = arguments[3]
  analysis_type = arguments[4]
  indices = [int(i) for i in arguments[5:]]

  normal_traj_path, altered_traj_path = create_trajectories(game_input_folder, output_folder, name_normal_traj, name_altered_traj, indices)
  analysis(output_folder, analysis_type, normal_traj_path, altered_traj_path)

if __name__ == "__main__":
    main(sys.argv[1:])


#name_altered = "knight_one_mau"
#path_normal_traj = "/home3/s3799042/Trajectories/Generated_trajectories/trajectory_depth_6-2.npy"
#path_altered_traj = "/home3/s3799042/Trajectories/Generated_trajectories/mind_control/trajectory_" + name_altered + ".npy"
"""
fens = None
if not os.path.isfile(path_normal_traj) or not os.path.isfile(path_altered_traj):  
  fens = get_all_fens()

out_folder_mind_control = Path("/home3/s3799042/Trajectories/Generated_trajectories/mind_control/")
out_folder_normal = Path("/home3/s3799042/Trajectories/Generated_trajectories/")

lc0 = None
if not os.path.isfile(path_normal_traj):
  lc0 = activations.load_lc0()
  with torch.no_grad():
    activations.process_trajectories(lc0, fens, "depth_6-2", out_folder_normal, depth=6)

if not os.path.isfile(path_altered_traj):
  if lc0 is None:
    lc0 = mind_control.load_lc0()
    
  sae = mind_control.load_sae()
  
  lm_indices, lm_factors = mind_control.get_latent_manipulator(63744, factor=4)#king move 63744, 7722, 34463, 63751,106345, 79750, 83977, 11679, factor=2) #pawn flank 59983, 7734, 18678, 106357, #knight fork: 18677, 32541, 63744
     
  with torch.no_grad():
    mind_control.altered_trajectories(out_folder_mind_control, sae, lc0, fens, name_altered, lm_indices, lm_factors, depth=6)
"""
#normal_traj = np.load(path_normal_traj)
#altered_traj = np.load(path_altered_traj)

#top_down_analysis(normal_traj, altered_traj)

#bottom_up_analysis_pawn_flank(normal_traj, altered_traj)

#traj_pairs = bottom_up_analysis_king_move(normal_traj, altered_traj)


#generate_chess_html(traj_pairs[10:50], "/home3/s3799042/Trajectories/normal_vs_mind_control.html")
#print(f"len normal: {len(normal_traj[:, 1])} len altered: {len(altered_traj[:,1])}") 
#print(get_count_normal_altered_d7d5(normal_traj[:, 1], altered_traj[:,1]))

#print("Altered:")
#print_label_count(altered_traj[:,1])

#print("Normal:")
#print_label_count(normal_traj[:,1])